<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>南山的博客</title><link>https://nanshanvv.github.io</link><description>LC算法训练 | 日常Blog</description><copyright>南山的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/77189526?v=4</url><title>avatar</title><link>https://nanshanvv.github.io</link></image><lastBuildDate>Fri, 26 Jul 2024 08:15:54 +0000</lastBuildDate><managingEditor>南山的博客</managingEditor><ttl>60</ttl><webMaster>南山的博客</webMaster><item><title>算法训练DAY3 ｜ 链表部分（上）</title><link>https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY3%20%EF%BD%9C%20-lian-biao-bu-fen-%EF%BC%88-shang-%EF%BC%89.html</link><description># 链表基础&#13;
&#13;
## 链表节点的构造&#13;
&#13;
```cpp&#13;
// 单链表&#13;
struct ListNode {&#13;
    int val;  // 节点上存储的元素&#13;
    ListNode *next;  // 指向下一个节点的指针&#13;
    #ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，不加也行因为cpp默认生成一个构造函数&#13;
};&#13;
```&#13;
&#13;
- **构造函数**:&#13;
  - `LinkedNode(int val): val(val), next(nullptr) {}` 是一个构造函数。</description><guid isPermaLink="true">https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY3%20%EF%BD%9C%20-lian-biao-bu-fen-%EF%BC%88-shang-%EF%BC%89.html</guid><pubDate>Fri, 26 Jul 2024 08:12:28 +0000</pubDate></item><item><title>算法训练DAY2 | LC977. 有序数组的平方(双指针法)，LC209. 长度最小的子数组(滑动窗口法), LC59. 螺旋矩阵II</title><link>https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY2%20-%20LC977.%20-you-xu-shu-zu-de-ping-fang-%28-shuang-zhi-zhen-fa-%29%EF%BC%8CLC209.%20-chang-du-zui-xiao-de-zi-shu-zu-%28-hua-dong-chuang-kou-fa-%29%2C%20LC59.%20-luo-xuan-ju-zhen-II.html</link><description># 有序数组的平方(双指针法)&#13;
&#13;
### [[题目：Leetcode.977](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)&#13;
&#13;
### 视频讲解：[[代码随想录](https://www.bilibili.com/video/BV1QB4y1D7ep/)](https://www.bilibili.com/video/BV1QB4y1D7ep/)&#13;
&#13;
**重点：理解什么时候该用双指针法**&#13;
&#13;
&#13;
&#13;
## [[复习vector](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)&#13;
&#13;
- vector():创建一个空vector&#13;
- vector(int nSize):创建一个vector,元素个数为nSize&#13;
- vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t&#13;
- vector(const vector&amp;):复制构造函数&#13;
- vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中&#13;
&#13;
## 双指针法&#13;
&#13;
数组其实是有序的， 只不过负数平方之后可能成为最大数了。</description><guid isPermaLink="true">https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY2%20-%20LC977.%20-you-xu-shu-zu-de-ping-fang-%28-shuang-zhi-zhen-fa-%29%EF%BC%8CLC209.%20-chang-du-zui-xiao-de-zi-shu-zu-%28-hua-dong-chuang-kou-fa-%29%2C%20LC59.%20-luo-xuan-ju-zhen-II.html</guid><pubDate>Fri, 05 Jul 2024 14:41:31 +0000</pubDate></item><item><title>算法训练DAY1 | LC704. 二分查找，LC27. 移除元素</title><link>https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY1%20-%20LC704.%20-er-fen-cha-zhao-%EF%BC%8CLC27.%20-yi-chu-yuan-su.html</link><description>## 二分搜索法&#13;
&#13;
### [[题目：Leetcode.704](https://leetcode.cn/problems/binary-search/submissions/543800734/)](https://leetcode.cn/problems/binary-search/submissions/543800734/)&#13;
&#13;
### 视频讲解：[[代码随想录](https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=a693917376813c5b1608ec0a4132e636)](https://www.bilibili.com/video/BV1fA4y1o715/?vd_source=a693917376813c5b1608ec0a4132e636)&#13;
&#13;
### 重点：&#13;
&#13;
1. 对于`while(left &lt; right)` 还是 `while(left &lt;= right)`的判断&#13;
2. 对于是`right = middle`还是`right = middle - 1`的判断&#13;
&#13;
&#13;
&#13;
**关注点：主要是对于区间的定义，是[left,right] , [left,right)**&#13;
&#13;
#### 1.闭区间写法&#13;
&#13;
```c++&#13;
class Solution {&#13;
public:&#13;
    int search(vector&lt;int&gt;&amp; nums, int target) {&#13;
        int left = 0;&#13;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]&#13;
        while (left &lt;= right) { // 当left==right，区间[left, right]依然有效，所以用 &lt;=&#13;
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2&#13;
            if (nums[middle] &gt; target) {&#13;
                right = middle - 1; // target 在左区间，所以[left, middle - 1]&#13;
            } else if (nums[middle] &lt; target) {&#13;
                left = middle + 1; // target 在右区间，所以[middle + 1, right]&#13;
            } else { // nums[middle] == target&#13;
                return middle; // 数组中找到目标值，直接返回下标&#13;
            }&#13;
        }&#13;
        // 未找到目标值&#13;
        return -1;&#13;
    }&#13;
};&#13;
```&#13;
&#13;
**笔记：**&#13;
&#13;
​	**1.因为是闭区间，所以while(left &lt;= right)**&#13;
&#13;
​	如果该数组为[8]，因为闭区间 left = right 存在，所以用 while(left &lt;= right)&#13;
&#13;
​	**2.因为是if(num[middle] &gt; target), 所以 right = middle -1 （middle+1同理）**&#13;
&#13;
​	因为 if(num[middle] &gt; target) 已经限制 num[middle]！=target ，所以直接 right = middle -1&#13;
&#13;
&#13;
&#13;
#### 2.左闭右开写法&#13;
&#13;
```c++&#13;
class Solution {&#13;
public:&#13;
    int search(vector&lt;int&gt;&amp; nums, int target) {&#13;
        int left = 0;&#13;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)&#13;
        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;&#13;
            int middle = left + ((right - left) &gt;&gt; 1);&#13;
            if (nums[middle] &gt; target) {&#13;
                right = middle; // target 在左区间，在[left, middle)中&#13;
            } else if (nums[middle] &lt; target) {&#13;
                left = middle + 1; // target 在右区间，在[middle + 1, right)中&#13;
            } else { // nums[middle] == target&#13;
                return middle; // 数组中找到目标值，直接返回下标&#13;
            }&#13;
        }&#13;
        // 未找到目标值&#13;
        return -1;&#13;
    }&#13;
};&#13;
```&#13;
&#13;
**笔记：**&#13;
&#13;
​	**1.因为是左闭右开区间，所以while(left &lt; right)**&#13;
&#13;
​	如果有数组为[8），因为闭区间 left = right 不存在，所以用 while(left &lt; right) &#13;
&#13;
​	**2.因为是if(num[middle] &gt; target)且左闭右开, 所以 right = middle **&#13;
&#13;
​	因为是左闭右开且 target 在左区间，所以 right 直接取 middle 后区间为 [left,middle) ,下一个查询区间不会去比较 nums[middle]，所以 right = middle; 如果 right = middle -1 的话区间就成 [left , middle - 1), 假如 middle-1 就是 target 就比不到了&#13;
&#13;
​	**注意：当target在右区间，left = middle + 1** &#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
## 移除元素&#13;
&#13;
### [[题目：Leetcode.27](https://leetcode.cn/problems/remove-element/)](https://leetcode.cn/problems/remove-element/)&#13;
&#13;
### 视频讲解：[[代码随想录](https://www.bilibili.com/video/BV12A4y1Z7LP/?spm_id_from=333.788&amp;vd_source=a693917376813c5b1608ec0a4132e636)](https://www.bilibili.com/video/BV12A4y1Z7LP/?spm_id_from=333.788&amp;vd_source=a693917376813c5b1608ec0a4132e636)&#13;
&#13;
### **重点：双指针法**&#13;
&#13;
&#13;
&#13;
### 我使用的暴力解法&#13;
&#13;
```c++&#13;
class Solution {&#13;
public:&#13;
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {&#13;
        int n = 0;&#13;
        int m[100] = {};&#13;
        for (int i = 0; i &lt; nums.size(); i++) {&#13;
            if (nums[i] != val) {&#13;
                m[n] = nums[i];&#13;
                n++;&#13;
            }&#13;
        }&#13;
&#13;
        for (int i = 0; i &lt; n; i++) {&#13;
            nums[i] = m[i];&#13;
        }&#13;
        return n;&#13;
    }&#13;
};&#13;
```&#13;
&#13;
&#13;
&#13;
### 双指针法（快慢指针法）&#13;
![27 移除元素-双指针法](https://github.com/nanshanvv/nanshanvv.github.io/assets/77189526/ee7d5620-b500-4504-b036-89f5aed99512)&#13;
&#13;
- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组&#13;
- 慢指针：指向更新 新数组下标的位置&#13;
&#13;
&#13;
&#13;
```c++&#13;
// 时间复杂度：O(n)&#13;
// 空间复杂度：O(1)&#13;
class Solution {&#13;
public:&#13;
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {&#13;
        int slowIndex = 0;&#13;
        for (int fastIndex = 0; fastIndex &lt; nums.size(); fastIndex++) {&#13;
            if (val != nums[fastIndex]) {&#13;
                nums[slowIndex++] = nums[fastIndex];&#13;
            }&#13;
        }&#13;
        return slowIndex;&#13;
    }&#13;
};&#13;
```。</description><guid isPermaLink="true">https://nanshanvv.github.io/post/suan-fa-xun-lian-DAY1%20-%20LC704.%20-er-fen-cha-zhao-%EF%BC%8CLC27.%20-yi-chu-yuan-su.html</guid><pubDate>Wed, 03 Jul 2024 15:34:01 +0000</pubDate></item><item><title>你好世界</title><link>https://nanshanvv.github.io/post/ni-hao-shi-jie.html</link><description>hello world！。</description><guid isPermaLink="true">https://nanshanvv.github.io/post/ni-hao-shi-jie.html</guid><pubDate>Tue, 02 Jul 2024 12:14:05 +0000</pubDate></item></channel></rss>